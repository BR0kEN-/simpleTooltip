/**
* Original Author: Remiz Rahnas
* Original Author URL: http://www.htmlremix.com
* Published date: 2008/09/24
*
* Changes by Nick Fetchak:
* - IE8 standards mode compatibility
* - VML elements now positioned behind original box rather than inside of it - should be less prone to breakage
* Published date : 2009/11/18
*
* Changes by BR0kEN, Firstvector.org:
* - Code refactoring
* - Remove IE6 support
* Published date : 2013/09/09
*/


<public:attach event="oncontentready" onevent="oncontentready('v08vnSVo78t4JfjH')" />
<script>

(function(w, d, u){
	'use strict';

	function findPos(obj) {
		var curleft = curtop = 0;

		if (obj.offsetParent) {
			do {
				curleft += obj.offsetLeft;
				curtop += obj.offsetTop;
			} while (obj = obj.offsetParent);
		}

		return({'x': curleft, 'y': curtop});
	}

	function oncontentready(classID) {
		if (this.className.match(classID)) return(false);

		if (!d.namespaces.v) d.namespaces.add('v', 'urn:schemas-microsoft-com:vml');

		this.className = this.className.concat(' ', classID);

		var arcSize = Math.min(parseInt(
			this.currentStyle['-moz-border-radius'] ||
			this.currentStyle['-webkit-border-radius'] ||
			this.currentStyle['border-radius'] ||
			this.currentStyle['-khtml-border-radius']) / Math.min(this.offsetWidth, this.offsetHeight), 1
		),
		fillColor = this.currentStyle.backgroundColor,
		fillSrc = this.currentStyle.backgroundImage.replace(/^url\("(.+)"\)$/, '$1'),
		strokeColor = this.currentStyle.borderColor,
		strokeWeight = parseInt(this.currentStyle.borderWidth),
		stroked = 'true';

		if (isNaN(strokeWeight)) {
			strokeWeight = 0;
			strokeColor = fillColor;
			stroked = 'false';
		}

		this.style.background = 'transparent';
		this.style.borderColor = 'transparent';

		var el = this, limit = 100, i = 0;

		while ((typeof(el) != 'unknown') && (el.currentStyle.position != 'relative') && (el.tagName != 'BODY')) {
			el = el.parentElement;
			++i;
			if (i >= limit) return !1;
		}

		var el_zindex = parseInt(el.currentStyle.zIndex);

		if (isNaN(el_zindex)) el_zindex = 0;

		var rect_size = {
			'width': this.offsetWidth - strokeWeight,
			'height': this.offsetHeight - strokeWeight
		};

		var el_pos = findPos(el), this_pos = findPos(this);

		this_pos.y = this_pos.y + (0.5 * strokeWeight) - el_pos.y;
		this_pos.x = this_pos.x + (0.5 * strokeWeight) - el_pos.x;

		var rect = d.createElement('v:roundrect');

		rect.arcsize = arcSize +'px';
		rect.strokecolor = strokeColor;
		rect.strokeWeight = strokeWeight +'px';
		rect.stroked = stroked;
		rect.style.display = 'block';
		rect.style.position = 'absolute';
		rect.style.top = this_pos.y +'px';
		rect.style.left = this_pos.x +'px';
		rect.style.width = rect_size.width +'px';
		rect.style.height = rect_size.height +'px';
		rect.style.antialias = true;
		rect.style.zIndex = el_zindex - 1;

		var fill = d.createElement('v:fill');

		fill.color = fillColor;
		fill.src = fillSrc;
		fill.type = 'tile';

		rect.appendChild(fill);
		el.appendChild(rect);

		if (typeof(w.rounded_elements) == u) {
			w.rounded_elements = new Array();

			w.onresize = function(){
				if (typeof(w.rounded_elements) == u) return !1;

				for (var i in w.rounded_elements) {
					var el = w.rounded_elements[i], strokeWeight = parseInt(el.currentStyle.borderWidth);

					if (isNaN(strokeWeight)) strokeWeight = 0;

					var parent_pos = findPos(el.vml.parentNode), pos = findPos(el);

					pos.y = pos.y + (0.5 * strokeWeight) - parent_pos.y;
					pos.x = pos.x + (0.5 * strokeWeight) - parent_pos.x;

					el.vml.style.top = pos.y +'px';
					el.vml.style.left = pos.x +'px';
				}
			}
		}

		this.element.vml = rect;

		w.rounded_elements.push(this.element);
	}

})(window, document, undefined);

</script>